<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/post/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/post/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/post/_next/static/css/4c854de46d48830e.css" data-precedence="next"/><link rel="stylesheet" href="/post/_next/static/css/2174f9ebd56064d0.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/post/_next/static/chunks/webpack-b40652f442f0644a.js"/><script src="/post/_next/static/chunks/dff3f15b-2fd8bf3a8199a42b.js" async=""></script><script src="/post/_next/static/chunks/653-7c61c837a2602a24.js" async=""></script><script src="/post/_next/static/chunks/main-app-c853e746969ce228.js" async=""></script><script src="/post/_next/static/chunks/845-15cc836a3e298aca.js" async=""></script><script src="/post/_next/static/chunks/app/layout-48acbd41c0a1e702.js" async=""></script><script src="/post/_next/static/chunks/884-702bfcfb15402d08.js" async=""></script><script src="/post/_next/static/chunks/115-32cf408379cbc1cd.js" async=""></script><script src="/post/_next/static/chunks/app/not-found-1f8e90f678f47231.js" async=""></script><script src="/post/_next/static/chunks/app/(id)/(prebuild)/e13791c3-cda5-4860-b82b-57985ccd18e9/page-6f95bf2b91985e18.js" async=""></script><script src="/post/_next/static/chunks/app/global-error-1dbaf2bdab2eb1fe.js" async=""></script><meta name="next-size-adjust" content=""/><title>TSC 빌드 없이 TypeScript 커맨드 툴 개발하기</title><meta name="description" content="읽는 시간: 7분안녕하세요, Frontend Engineer 정석호입니다"/><meta name="robots" content="index, follow"/><link rel="canonical" href="https://blog.creco.dev/post/e13791c3-cda5-4860-b82b-57985ccd18e9/"/><meta property="og:title" content="TSC 빌드 없이 TypeScript 커맨드 툴 개발하기"/><meta property="og:description" content="읽는 시간: 7분안녕하세요, Frontend Engineer 정석호입니다"/><meta property="og:image" content="https://divopsor.github.io/blog-images/2025/ts-commandline.png"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="TSC 빌드 없이 TypeScript 커맨드 툴 개발하기"/><meta name="twitter:description" content="읽는 시간: 7분안녕하세요, Frontend Engineer 정석호입니다"/><meta name="twitter:image" content="https://divopsor.github.io/blog-images/2025/ts-commandline.png"/><link rel="icon" href="/post/favicon.ico" type="image/x-icon" sizes="16x16"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/post/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_178516 __variable_66e6cd antialiased"><div class="bg-[#232323] min-h-screen text-[#DEDEDD] text-base"><div class="desktop-ui flex justify-center bg-[#232323] min-h-screen text-[#DEDEDD] text-base"><div class="bg-[#2B2B29] max-w-[1200px] w-full py-[16px] px-[20px] shadow-[0_0_4px_20px_#2B2B29] text-base"><main class="max-w-[840px] mx-auto"><section class="py-[24px]"><a class="hover:text-white" href="/post/"><h1 class="text-[3.6rem] font-extrabold">Creco&#x27;s Blog</h1></a></section><div class="h-[20px]"></div><h3 class="text-[2.4rem] text-center underline break-normal">Tech</h3><div class="h-[20px]"></div><h1 class="text-[48px] text-center underline break-keep">TSC 빌드 없이 TypeScript 커맨드 툴 개발하기</h1><div class="flex"><span class="bg-[#232323] text-[#DEDEDD] text-base px-[10px] py-[5px] rounded-md flex mr-0 ml-auto w-[75px]"><span>조회수</span><span class="mr-0 ml-auto">296</span></span></div><div class="h-[20px]"></div><hr class="w-full border-t border-gray-200/50 transform scale-y-[0.3] my-[10px]"/><article class="PostPage_post__SphU4" style="font-size:1.6rem;word-break:keep-all"><h4><code>읽는 시간: 7분</code></h4><br><p><img src="https://divopsor.github.io/blog-images/2025/ts-commandline.png" alt=""></p><br><p>안녕하세요, Frontend Engineer 정석호입니다.</p><br><p>지난 글에서는 shell 기반의 커맨드 툴을 소개했었죠? 이번에는 TypeScript로 CLI를 만들면서 로컬 개발 속도를 높이기 위해 어떤 환경 구성이 유용했는지 소개해 보려고 해요. 매번 <code>tsc</code>로 빌드해서 <code>dist</code>를 확인하는 건 꽤 번거롭잖아요. 그래서 요즘은 esbuild나 tsx처럼 빠르게 실행 가능한 방식이 대세인데요, 저도 이것저것 시도해 보다가 괜찮은 셋업을 정리하게 됐습니다. 편의를 위해 Node.js의 ESM 환경에서 진행하는 걸 보여드릴게요!</p><br><h1>CLI 개발에서 고려할 점들</h1><br><p>CLI 툴을 만들 때 대부분의 개발자는 <code>src</code> 디렉토리에 TypeScript 소스를 작성하고, <code>bin</code> 디렉토리에는 실행 스크립트를 두는 구조를 선호하실 거예요. 저도 그렇게 구성했는데, 다음과 같은 요구사항이 생겼습니다.</p><br><ol><br><li>개발 중엔 TypeScript 소스를 직접 실행할 수 있어야 해요.</li><br><li>배포 후에는 <code>tsc</code>나 <code>esbuild</code>를 통해 번들된 JavaSript 파일을 실행해야겠죠.</li><br><li>import 구문은 <code>import { foo } from "./foo.js"</code>처럼 <code>.js</code> 확장자를 쓰도록 ESM 표준을 따릅니다.</li><br></ol><br><p>이걸 만족하려면 <code>bin/dev-cli.js</code>는 직접 <code>src/index.ts</code> 파일을 불러와야 하고, <code>bin/cli.js</code>는 번들된 <code>dist/index.js</code>를 참조해야 해요.</p><br><h1>register가 뭐길래?</h1><br><p><code>ts-node</code>나 <code>tsx</code> 같은 도구가 이런 걸 가능하게 해 주는 이유는 바로 <strong>register</strong> 라는 개념 덕분이에요.<br>Node.js에서 어떤 파일을 실행할 때, 해당 파일을 JS가 아닌 다른 형식(예: ts, jsx 등)으로 동작하게 하고 싶을 때 <code>loader</code>나 <code>register hook</code>을 이용하죠.</p><br><p>즉, 실행 전에 컴파일 과정을 자동으로 끼워넣는 방식이에요.<br>이걸 활용하면 <code>src/index.ts</code>를 미리 빌드하지 않고도 직접 실행할 수 있게 됩니다.</p><br><p>궁금하다면 <a href="https://nodejs.org/api/module.html#moduleregisterspecifier-parenturl-options">이곳</a>에서 더 자세한 정보를 확인할 수 있어요!</p><br><h1>ts-node로 실행 환경 구성하기</h1><br><p>먼저 <code>ts-node</code> 방식부터 볼게요. 이 방법은 Node.js에 좀 더 가깝고, 디버깅도 익숙한 느낌이에요.</p><br><h4>bash 실행 시</h4><br><pre><code class="language-bash">node --experimental-specifier-resolution=node --experimental-loader ts-node/esm.mjs ./src/index.ts<br></code></pre><br><h4>dev-cli.js (개발용)</h4><br><pre><code class="language-ts">#!/usr/bin/env node<br><br>import { register } from "node:module";<br>import { pathToFileURL } from "node:url";<br><br>register("ts-node/esm", pathToFileURL("./"));<br><br>import("../src/index.ts");<br></code></pre><br><h4>cli.js (배포용)</h4><br><pre><code class="language-ts">#!/usr/bin/env node<br><br>import("../dist/index.js");<br></code></pre><br><p>구성은 간단해 보여도, tsconfig 설정과 <code>import</code> 경로, 확장자까지 꼼꼼히 챙겨야 제대로 동작합니다. 특히 ESM 환경에서는 확장자를 빼먹으면 바로 에러가 나요.ㅎㅎ</p><br><h1>tsx로 구성해 보기</h1><br><p>이번엔 <code>tsx</code> 기반이에요. esbuild를 기반으로 동작하기 때문에 실행 속도가 정말 빠르다는 게 장점이에요.</p><br><h4>bash 실행 시</h4><br><pre><code class="language-bash">yarn tsx ./src/index.ts<br></code></pre><br><h4>dev-cli.js (개발용)</h4><br><pre><code class="language-ts">#!/usr/bin/env tsx<br><br>import { tsImport } from "tsx/esm/api";<br><br>await tsImport("../src/index.ts", import.meta.url);<br></code></pre><br><h4>cli.js (배포용)</h4><br><pre><code class="language-ts">#!/usr/bin/env node<br><br>import("../dist/index.js");<br></code></pre><br><p>이 방식은 <code>tsx</code>가 알아서 loader 역할까지 다 해 주기 때문에 Node.js 옵션을 따로 설정할 필요가 없어요.<br>그리고 <code>tsImport</code>를 쓰면 <code>import</code> 문도 동적으로 처리 가능해서 유연해요.</p><br><h1>ts-node vs tsx, 직접 비교해본 실행 속도</h1><br><p>이론만 봐선 차이가 잘 와닿지 않죠? 실제로 시간 측정을 해봤습니다.</p><br><pre><code>➜  hello-tsx-cli git:(main) ✗ time yarn hello-tsx-cli-dev<br>Hello, World!<br>yarn hello-tsx-cli-dev  0.21s user 0.04s system 123% cpu 0.204 total<br><br>➜  hello-ts-node-cli git:(main) ✗ time yarn hello-ts-node-cli-dev<br>Hello, World!<br>yarn hello-ts-node-cli-dev  0.98s user 0.08s system 215% cpu 0.495 total<br></code></pre><br><p>결과를 보면 알 수 있듯이 tsx 쪽이 훨씬 빠르더라구요. 물론 이건 아주 단순한 실행 환경에서 측정한 거라 복잡한 프로젝트에선 차이가 달라질 수 있겠죠.</p><br><h1>마무리하며</h1><br><p>개발 속도를 끌어올리고 싶은 상황이라면 <code>tsx</code>가 꽤 매력적인 선택이에요. 특히 setup이 간단하고 빠르게 작동하는 게 인상적이었어요.<br>반대로 <code>ts-node</code>는 좀 더 Node.js의 철학에 가까워서 디버깅이나 설정을 미세하게 조절하고 싶을 땐 유리합니다.</p><br><p>결국은 팀 상황이나 프로젝트 성격에 따라 선택이 달라지겠지만, 둘 다 훌륭한 옵션이에요.<br>개발 중에는 tsx, 배포는 번들된 js를 쓰는 하이브리드 구성이 참 좋더라구요.</p><br><p>혹시 비슷한 고민 중이신 분이 있다면, 저처럼 한 번 직접 비교해보시는 걸 추천드려요!</p><br><p>제가 작성한 코드가 궁금하시다면, <a href="https://github.com/CreatiCoding/ts-cli-playground/tree/main">여기</a>로 오시면 됩니다.</p><br><p>공유하고 싶은 사례가 있거나 궁금한 점은 댓글이나 이슈로 남겨주세요 🙌</p></article><div class="h-[60px]"></div></main></div></div></div><!--$--><!--/$--><!--$--><!--/$--><script src="/post/_next/static/chunks/webpack-b40652f442f0644a.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7915,[\"845\",\"static/chunks/845-15cc836a3e298aca.js\",\"177\",\"static/chunks/app/layout-48acbd41c0a1e702.js\"],\"Provider\"]\n3:I[1305,[],\"\"]\n4:I[6861,[],\"\"]\n5:I[9183,[\"884\",\"static/chunks/884-702bfcfb15402d08.js\",\"115\",\"static/chunks/115-32cf408379cbc1cd.js\",\"345\",\"static/chunks/app/not-found-1f8e90f678f47231.js\"],\"default\"]\n6:I[8641,[\"845\",\"static/chunks/845-15cc836a3e298aca.js\",\"177\",\"static/chunks/app/layout-48acbd41c0a1e702.js\"],\"ClientAnalytics\"]\n7:I[3519,[\"884\",\"static/chunks/884-702bfcfb15402d08.js\",\"115\",\"static/chunks/115-32cf408379cbc1cd.js\",\"285\",\"static/chunks/app/(id)/(prebuild)/e13791c3-cda5-4860-b82b-57985ccd18e9/page-6f95bf2b91985e18.js\"],\"PostPage\"]\n9:I[5023,[],\"MetadataBoundary\"]\nb:I[5023,[],\"OutletBoundary\"]\ne:I[3573,[],\"AsyncMetadataOutlet\"]\n10:I[5023,[],\"ViewportBoundary\"]\n12:I[2361,[\"219\",\"static/chunks/app/global-error-1dbaf2bdab2eb1fe.js\"],\"default\"]\n:HL[\"/post/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/post/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/post/_next/static/css/4c854de46d48830e.css\",\"style\"]\n:HL[\"/post/_next/static/css/2174f9ebd56064d0.css\",\"style\"]\n8:T1889,"])</script><script>self.__next_f.push([1,"\u003ch4\u003e\u003ccode\u003e읽는 시간: 7분\u003c/code\u003e\u003c/h4\u003e\u003cbr\u003e\u003cp\u003e\u003cimg src=\"https://divopsor.github.io/blog-images/2025/ts-commandline.png\" alt=\"\"\u003e\u003c/p\u003e\u003cbr\u003e\u003cp\u003e안녕하세요, Frontend Engineer 정석호입니다.\u003c/p\u003e\u003cbr\u003e\u003cp\u003e지난 글에서는 shell 기반의 커맨드 툴을 소개했었죠? 이번에는 TypeScript로 CLI를 만들면서 로컬 개발 속도를 높이기 위해 어떤 환경 구성이 유용했는지 소개해 보려고 해요. 매번 \u003ccode\u003etsc\u003c/code\u003e로 빌드해서 \u003ccode\u003edist\u003c/code\u003e를 확인하는 건 꽤 번거롭잖아요. 그래서 요즘은 esbuild나 tsx처럼 빠르게 실행 가능한 방식이 대세인데요, 저도 이것저것 시도해 보다가 괜찮은 셋업을 정리하게 됐습니다. 편의를 위해 Node.js의 ESM 환경에서 진행하는 걸 보여드릴게요!\u003c/p\u003e\u003cbr\u003e\u003ch1\u003eCLI 개발에서 고려할 점들\u003c/h1\u003e\u003cbr\u003e\u003cp\u003eCLI 툴을 만들 때 대부분의 개발자는 \u003ccode\u003esrc\u003c/code\u003e 디렉토리에 TypeScript 소스를 작성하고, \u003ccode\u003ebin\u003c/code\u003e 디렉토리에는 실행 스크립트를 두는 구조를 선호하실 거예요. 저도 그렇게 구성했는데, 다음과 같은 요구사항이 생겼습니다.\u003c/p\u003e\u003cbr\u003e\u003col\u003e\u003cbr\u003e\u003cli\u003e개발 중엔 TypeScript 소스를 직접 실행할 수 있어야 해요.\u003c/li\u003e\u003cbr\u003e\u003cli\u003e배포 후에는 \u003ccode\u003etsc\u003c/code\u003e나 \u003ccode\u003eesbuild\u003c/code\u003e를 통해 번들된 JavaSript 파일을 실행해야겠죠.\u003c/li\u003e\u003cbr\u003e\u003cli\u003eimport 구문은 \u003ccode\u003eimport { foo } from \"./foo.js\"\u003c/code\u003e처럼 \u003ccode\u003e.js\u003c/code\u003e 확장자를 쓰도록 ESM 표준을 따릅니다.\u003c/li\u003e\u003cbr\u003e\u003c/ol\u003e\u003cbr\u003e\u003cp\u003e이걸 만족하려면 \u003ccode\u003ebin/dev-cli.js\u003c/code\u003e는 직접 \u003ccode\u003esrc/index.ts\u003c/code\u003e 파일을 불러와야 하고, \u003ccode\u003ebin/cli.js\u003c/code\u003e는 번들된 \u003ccode\u003edist/index.js\u003c/code\u003e를 참조해야 해요.\u003c/p\u003e\u003cbr\u003e\u003ch1\u003eregister가 뭐길래?\u003c/h1\u003e\u003cbr\u003e\u003cp\u003e\u003ccode\u003ets-node\u003c/code\u003e나 \u003ccode\u003etsx\u003c/code\u003e 같은 도구가 이런 걸 가능하게 해 주는 이유는 바로 \u003cstrong\u003eregister\u003c/strong\u003e 라는 개념 덕분이에요.\u003cbr\u003eNode.js에서 어떤 파일을 실행할 때, 해당 파일을 JS가 아닌 다른 형식(예: ts, jsx 등)으로 동작하게 하고 싶을 때 \u003ccode\u003eloader\u003c/code\u003e나 \u003ccode\u003eregister hook\u003c/code\u003e을 이용하죠.\u003c/p\u003e\u003cbr\u003e\u003cp\u003e즉, 실행 전에 컴파일 과정을 자동으로 끼워넣는 방식이에요.\u003cbr\u003e이걸 활용하면 \u003ccode\u003esrc/index.ts\u003c/code\u003e를 미리 빌드하지 않고도 직접 실행할 수 있게 됩니다.\u003c/p\u003e\u003cbr\u003e\u003cp\u003e궁금하다면 \u003ca href=\"https://nodejs.org/api/module.html#moduleregisterspecifier-parenturl-options\"\u003e이곳\u003c/a\u003e에서 더 자세한 정보를 확인할 수 있어요!\u003c/p\u003e\u003cbr\u003e\u003ch1\u003ets-node로 실행 환경 구성하기\u003c/h1\u003e\u003cbr\u003e\u003cp\u003e먼저 \u003ccode\u003ets-node\u003c/code\u003e 방식부터 볼게요. 이 방법은 Node.js에 좀 더 가깝고, 디버깅도 익숙한 느낌이에요.\u003c/p\u003e\u003cbr\u003e\u003ch4\u003ebash 실행 시\u003c/h4\u003e\u003cbr\u003e\u003cpre\u003e\u003ccode class=\"language-bash\"\u003enode --experimental-specifier-resolution=node --experimental-loader ts-node/esm.mjs ./src/index.ts\u003cbr\u003e\u003c/code\u003e\u003c/pre\u003e\u003cbr\u003e\u003ch4\u003edev-cli.js (개발용)\u003c/h4\u003e\u003cbr\u003e\u003cpre\u003e\u003ccode class=\"language-ts\"\u003e#!/usr/bin/env node\u003cbr\u003e\u003cbr\u003eimport { register } from \"node:module\";\u003cbr\u003eimport { pathToFileURL } from \"node:url\";\u003cbr\u003e\u003cbr\u003eregister(\"ts-node/esm\", pathToFileURL(\"./\"));\u003cbr\u003e\u003cbr\u003eimport(\"../src/index.ts\");\u003cbr\u003e\u003c/code\u003e\u003c/pre\u003e\u003cbr\u003e\u003ch4\u003ecli.js (배포용)\u003c/h4\u003e\u003cbr\u003e\u003cpre\u003e\u003ccode class=\"language-ts\"\u003e#!/usr/bin/env node\u003cbr\u003e\u003cbr\u003eimport(\"../dist/index.js\");\u003cbr\u003e\u003c/code\u003e\u003c/pre\u003e\u003cbr\u003e\u003cp\u003e구성은 간단해 보여도, tsconfig 설정과 \u003ccode\u003eimport\u003c/code\u003e 경로, 확장자까지 꼼꼼히 챙겨야 제대로 동작합니다. 특히 ESM 환경에서는 확장자를 빼먹으면 바로 에러가 나요.ㅎㅎ\u003c/p\u003e\u003cbr\u003e\u003ch1\u003etsx로 구성해 보기\u003c/h1\u003e\u003cbr\u003e\u003cp\u003e이번엔 \u003ccode\u003etsx\u003c/code\u003e 기반이에요. esbuild를 기반으로 동작하기 때문에 실행 속도가 정말 빠르다는 게 장점이에요.\u003c/p\u003e\u003cbr\u003e\u003ch4\u003ebash 실행 시\u003c/h4\u003e\u003cbr\u003e\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eyarn tsx ./src/index.ts\u003cbr\u003e\u003c/code\u003e\u003c/pre\u003e\u003cbr\u003e\u003ch4\u003edev-cli.js (개발용)\u003c/h4\u003e\u003cbr\u003e\u003cpre\u003e\u003ccode class=\"language-ts\"\u003e#!/usr/bin/env tsx\u003cbr\u003e\u003cbr\u003eimport { tsImport } from \"tsx/esm/api\";\u003cbr\u003e\u003cbr\u003eawait tsImport(\"../src/index.ts\", import.meta.url);\u003cbr\u003e\u003c/code\u003e\u003c/pre\u003e\u003cbr\u003e\u003ch4\u003ecli.js (배포용)\u003c/h4\u003e\u003cbr\u003e\u003cpre\u003e\u003ccode class=\"language-ts\"\u003e#!/usr/bin/env node\u003cbr\u003e\u003cbr\u003eimport(\"../dist/index.js\");\u003cbr\u003e\u003c/code\u003e\u003c/pre\u003e\u003cbr\u003e\u003cp\u003e이 방식은 \u003ccode\u003etsx\u003c/code\u003e가 알아서 loader 역할까지 다 해 주기 때문에 Node.js 옵션을 따로 설정할 필요가 없어요.\u003cbr\u003e그리고 \u003ccode\u003etsImport\u003c/code\u003e를 쓰면 \u003ccode\u003eimport\u003c/code\u003e 문도 동적으로 처리 가능해서 유연해요.\u003c/p\u003e\u003cbr\u003e\u003ch1\u003ets-node vs tsx, 직접 비교해본 실행 속도\u003c/h1\u003e\u003cbr\u003e\u003cp\u003e이론만 봐선 차이가 잘 와닿지 않죠? 실제로 시간 측정을 해봤습니다.\u003c/p\u003e\u003cbr\u003e\u003cpre\u003e\u003ccode\u003e➜  hello-tsx-cli git:(main) ✗ time yarn hello-tsx-cli-dev\u003cbr\u003eHello, World!\u003cbr\u003eyarn hello-tsx-cli-dev  0.21s user 0.04s system 123% cpu 0.204 total\u003cbr\u003e\u003cbr\u003e➜  hello-ts-node-cli git:(main) ✗ time yarn hello-ts-node-cli-dev\u003cbr\u003eHello, World!\u003cbr\u003eyarn hello-ts-node-cli-dev  0.98s user 0.08s system 215% cpu 0.495 total\u003cbr\u003e\u003c/code\u003e\u003c/pre\u003e\u003cbr\u003e\u003cp\u003e결과를 보면 알 수 있듯이 tsx 쪽이 훨씬 빠르더라구요. 물론 이건 아주 단순한 실행 환경에서 측정한 거라 복잡한 프로젝트에선 차이가 달라질 수 있겠죠.\u003c/p\u003e\u003cbr\u003e\u003ch1\u003e마무리하며\u003c/h1\u003e\u003cbr\u003e\u003cp\u003e개발 속도를 끌어올리고 싶은 상황이라면 \u003ccode\u003etsx\u003c/code\u003e가 꽤 매력적인 선택이에요. 특히 setup이 간단하고 빠르게 작동하는 게 인상적이었어요.\u003cbr\u003e반대로 \u003ccode\u003ets-node\u003c/code\u003e는 좀 더 Node.js의 철학에 가까워서 디버깅이나 설정을 미세하게 조절하고 싶을 땐 유리합니다.\u003c/p\u003e\u003cbr\u003e\u003cp\u003e결국은 팀 상황이나 프로젝트 성격에 따라 선택이 달라지겠지만, 둘 다 훌륭한 옵션이에요.\u003cbr\u003e개발 중에는 tsx, 배포는 번들된 js를 쓰는 하이브리드 구성이 참 좋더라구요.\u003c/p\u003e\u003cbr\u003e\u003cp\u003e혹시 비슷한 고민 중이신 분이 있다면, 저처럼 한 번 직접 비교해보시는 걸 추천드려요!\u003c/p\u003e\u003cbr\u003e\u003cp\u003e제가 작성한 코드가 궁금하시다면, \u003ca href=\"https://github.com/CreatiCoding/ts-cli-playground/tree/main\"\u003e여기\u003c/a\u003e로 오시면 됩니다.\u003c/p\u003e\u003cbr\u003e\u003cp\u003e공유하고 싶은 사례가 있거나 궁금한 점은 댓글이나 이슈로 남겨주세요 🙌\u003c/p\u003e"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"6BTDH022UDAQmikYVvTat\",\"p\":\"/post\",\"c\":[\"\",\"e13791c3-cda5-4860-b82b-57985ccd18e9\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"(id)\",{\"children\":[\"(prebuild)\",{\"children\":[\"e13791c3-cda5-4860-b82b-57985ccd18e9\",{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/post/_next/static/css/4c854de46d48830e.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[[\"$\",\"body\",null,{\"className\":\"__variable_178516 __variable_66e6cd antialiased\",\"children\":[\"$\",\"$L2\",null,{\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"$L5\",null,{}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/post/_next/static/css/2174f9ebd56064d0.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}],[\"$\",\"$L6\",null,{\"projectId\":\"G-4M82715ZRX\"}]]}]]}],{\"children\":[\"(id)\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"(prebuild)\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"e13791c3-cda5-4860-b82b-57985ccd18e9\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[\"$\",\"$L7\",null,{\"id\":\"e13791c3-cda5-4860-b82b-57985ccd18e9\",\"category\":\"Tech\",\"title\":\"TSC 빌드 없이 TypeScript 커맨드 툴 개발하기\",\"body\":\"$8\",\"viewCount\":296}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/post/_next/static/css/2174f9ebd56064d0.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$Lb\",null,{\"children\":[\"$Lc\",\"$Ld\",[\"$\",\"$Le\",null,{\"promise\":\"$@f\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"7oyU_Lw-m8__XknVLWiU9\",{\"children\":[[\"$\",\"$L10\",null,{\"children\":\"$L11\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$12\",[]],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"13:\"$Sreact.suspense\"\n14:I[3573,[],\"AsyncMetadata\"]\na:[\"$\",\"$13\",null,{\"fallback\":null,\"children\":[\"$\",\"$L14\",null,{\"promise\":\"$@15\"}]}]\n"])</script><script>self.__next_f.push([1,"d:null\n"])</script><script>self.__next_f.push([1,"11:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nc:null\n"])</script><script>self.__next_f.push([1,"15:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"TSC 빌드 없이 TypeScript 커맨드 툴 개발하기\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"읽는 시간: 7분안녕하세요, Frontend Engineer 정석호입니다\"}],[\"$\",\"meta\",\"2\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"link\",\"3\",{\"rel\":\"canonical\",\"href\":\"https://blog.creco.dev/post/e13791c3-cda5-4860-b82b-57985ccd18e9/\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"TSC 빌드 없이 TypeScript 커맨드 툴 개발하기\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"읽는 시간: 7분안녕하세요, Frontend Engineer 정석호입니다\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:image\",\"content\":\"https://divopsor.github.io/blog-images/2025/ts-commandline.png\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"TSC 빌드 없이 TypeScript 커맨드 툴 개발하기\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"읽는 시간: 7분안녕하세요, Frontend Engineer 정석호입니다\"}],[\"$\",\"meta\",\"10\",{\"name\":\"twitter:image\",\"content\":\"https://divopsor.github.io/blog-images/2025/ts-commandline.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/post/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]],\"error\":null,\"digest\":\"$undefined\"}\nf:{\"metadata\":\"$15:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>